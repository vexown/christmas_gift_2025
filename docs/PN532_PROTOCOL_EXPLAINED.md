# PN532 I2C Protocol Deep Dive

## Understanding What's Really Happening

This document explains the low-level I2C communication protocol between the ESP32 and PN532 NFC module.

---

## 1. I2C Basics Review

### What is I2C?
I2C (Inter-Integrated Circuit) is a **two-wire serial protocol**:
- **SDA (Serial Data)**: Bidirectional data line
- **SCL (Serial Clock)**: Clock signal generated by master

### Master-Slave Architecture
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ESP32  â”‚  SDA/SCL  â”‚  PN532  â”‚
â”‚ (Master)â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ (Slave) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### I2C Transaction Basics
```
START â†’ ADDRESS â†’ R/W â†’ ACK â†’ DATA â†’ ACK â†’ ... â†’ STOP
  |        |        |     |      |      |          |
  â””â”€ Begin â”‚        â”‚     â”‚      â”‚      â”‚          â””â”€ End transaction
           |        â”‚     â”‚      â”‚      â””â”€ Slave acknowledges data
           |        â”‚     â”‚      â””â”€ Data byte(s)
           |        â”‚     â””â”€ Slave acknowledges address
           |        â””â”€ Read(1) or Write(0)
           â””â”€ 7-bit device address (0x24 for PN532)
```

---

## 2. PN532 Protocol Layers

### Layer 1: I2C Physical Layer
- **Electrical signaling** on SDA/SCL wires
- **Clock stretching** allowed (slave can hold SCL low to pause master)
- **Pull-up resistors** required (typically 4.7kÎ©)

### Layer 2: PN532 Frame Protocol
All commands/responses are wrapped in frames:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PREAMBLE â”‚ START_1  â”‚ START_2  â”‚ LEN â”‚ LCS â”‚ TFI â”‚ DATA â”‚ CHECKSUM â”‚ POSTAMBLEâ”‚
â”‚   0x00   â”‚   0x00   â”‚   0xFF   â”‚     â”‚     â”‚     â”‚      â”‚          â”‚   0x00   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Field Breakdown:**
- **PREAMBLE**: Always `0x00` (start marker)
- **STARTCODE**: Always `0x00 0xFF` (frame sync)
- **LEN**: Length of data + TFI (1 byte)
- **LCS**: Length checksum = `~LEN + 1` (two's complement)
- **TFI**: Transfer Frame Identifier
  - `0xD4` = Host to PN532
  - `0xD5` = PN532 to Host
- **DATA**: Command/response payload
- **DCS**: Data checksum = `~(TFI + DATA bytes)`
- **POSTAMBLE**: Always `0x00` (end marker)

### Layer 3: PN532 Command Protocol
Each command has a specific structure and response.

---

## 3. Real Transaction Examples

### Example 1: Get Firmware Version

#### Step 1: Send Command Frame
```
Master writes to 0x24:
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚ 00 â”‚ 00 â”‚ FF â”‚ 02 â”‚ FE â”‚ D4 â”‚ 02 â”‚ 2A â”‚ 00 â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
  â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â””â”€ Postamble
  â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€ Checksum: ~(D4+02) = 2A
  â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Command: GetFirmwareVersion (0x02)
  â”‚    â”‚    â”‚    â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TFI: Hostâ†’PN532 (0xD4)
  â”‚    â”‚    â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LCS: ~0x02 + 1 = 0xFE
  â”‚    â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LEN: 2 bytes (TFI + CMD)
  â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Start Code
  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Start Code
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Preamble
```

#### Step 2: Wait and Read Status
```c
// Master polls PN532 until ready
while (true) {
    status = i2c_read_byte(0x24);
    if (status == 0x01) break;  // Ready!
    delay(10ms);
}
```

**What happens inside PN532:**
```
Time    PN532 State              Status Byte
-----   ---------------------    -----------
0ms     Processing command...    0x00 (busy)
5ms     Still processing...      0x00 (busy)
10ms    Still processing...      0x00 (busy)
15ms    ACK ready!               0x01 (ready!)
```

#### Step 3: Read ACK Frame
```
Master reads 7 bytes from 0x24:
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚ 01 â”‚ 00 â”‚ 00 â”‚ FF â”‚ 00 â”‚ FF â”‚ 00 â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚                  â””â”€ ACK pattern (always same)
  â””â”€ Status byte (0x01 = ready)
```

**ACK Frame Validation:**
```c
if (ack[1] == 0x00 && ack[2] == 0x00 && ack[3] == 0xFF &&
    ack[4] == 0x00 && ack[5] == 0xFF && ack[6] == 0x00) {
    // Valid ACK!
}
```

#### Step 4: Wait Again for Response
```c
// PN532 needs time to prepare actual response
delay(50ms);

// Poll until ready
while (true) {
    status = i2c_read_byte(0x24);
    if (status == 0x01) break;
    delay(10ms);
}
```

#### Step 5: Read Response Frame
```
Master reads 13 bytes from 0x24:
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
â”‚ 01 â”‚ 00 â”‚ 00 â”‚ FF â”‚ 06 â”‚ FA â”‚ D5 â”‚ 03 â”‚ 32 â”‚ 01 â”‚ 06 â”‚ 07 â”‚ E8 â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚    â”‚    â”‚    â”‚    â”‚    â””â”€ Checksum
  â”‚                 â”‚              â”‚    â”‚    â”‚    â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€ Support flags
  â”‚                 â”‚              â”‚    â”‚    â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Revision
  â”‚                 â”‚              â”‚    â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Version
  â”‚                 â”‚              â”‚    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ IC (chip ID)
  â”‚                 â”‚              â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CMD+1 (0x02+1=0x03)
  â”‚                 â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TFI (PN532â†’Host)
  â”‚                 â””â”€ Frame header (LEN=6, LCS=0xFA)
  â””â”€ Status byte (0x01 = data ready)
```

**Parsing:**
```c
uint8_t ic      = response[8];  // 0x32 = PN532
uint8_t version = response[9];  // 0x01 = v1
uint8_t rev     = response[10]; // 0x06 = .6
// Result: PN532 v1.6
```

---

## 4. The Status Byte Protocol

This is **critical** and unique to PN532 I2C mode!

### Status Byte Values
```c
0x00 = PN532 is busy (processing, not ready to communicate)
0x01 = PN532 is ready (data available or ready to receive)
```

### Why It's Needed
```
Without Status Byte:
Master: "Give me data!"
PN532:  *still processing* â†’ Sends garbage
Master: "This data is corrupted!" âŒ

With Status Byte:
Master: "Are you ready?"
PN532:  "0x00" (not yet)
Master: *waits 10ms*
Master: "Are you ready now?"
PN532:  "0x01" (yes!)
Master: "Give me data!"
PN532:  *sends valid data* âœ“
```

### Implementation Pattern
```c
// Always check status before reading real data
uint8_t status;
do {
    i2c_read(address, &status, 1);
    if (status == 0x01) break;
    delay(10ms);
} while (not_timeout);

// Now safe to read actual data
i2c_read(address, buffer, length);
```

---

## 5. Timing Requirements

### Critical Delays

```c
// After hardware reset
gpio_set(RST, HIGH);
delay(500ms);  // â† PN532 boots, initializes NFC hardware
               //   Without this: chip not ready!

// After sending command
i2c_write(command);
delay(10ms);   // â† PN532 parses command, prepares ACK
               //   Without this: status still 0x00

// After reading ACK, before reading response  
read_ack();
delay(50ms);   // â† PN532 executes command, prepares response
               //   Without this: response not ready!
```

### Why Delays Matter
```
CPU Speed:       ESP32 @ 240MHz
PN532 Speed:     ~27MHz + NFC antenna operations

ESP32 can send I2C command in ~100 microseconds
PN532 needs 10-50 milliseconds to process it

Ratio: 100:1 to 500:1 slower!
```

---

## 6. Common Pitfalls & Solutions

### Pitfall 1: Reading Too Early
```c
// WRONG
i2c_write(command);
i2c_read(response);  // â† PN532 not ready! NACK error!

// CORRECT
i2c_write(command);
wait_for_ready();    // â† Poll status byte
i2c_read(response);  // â† Now safe
```

### Pitfall 2: Wrong Reset Polarity
```c
// WRONG (chip stuck in reset)
gpio_set(RST, 0);  // Release
delay(100ms);
gpio_set(RST, 1);  // Reset â† Backwards!

// CORRECT (active-low reset)
gpio_set(RST, 0);  // Hold in reset
delay(100ms);
gpio_set(RST, 1);  // Release - chip boots
delay(500ms);      // Wait for boot
```

### Pitfall 3: Ignoring Status Byte
```c
// WRONG (includes status in data)
uint8_t buffer[7];
i2c_read(buffer, 7);
// buffer[0] = 0x01 (status byte!)
// buffer[1-6] = actual ACK
// Comparison fails because offset is wrong!

// CORRECT
uint8_t buffer[7];
i2c_read(buffer, 7);
// buffer[0] = status (check it!)
// buffer[1-6] = ACK (compare from offset 1)
if (memcmp(buffer+1, ACK, 6) == 0) { ... }
```

### Pitfall 4: Not Validating Frames
```c
// WRONG (trust all data)
uint8_t response[13];
i2c_read(response, 13);
uint8_t version = response[9];  // Might be garbage!

// CORRECT (validate frame structure)
if (response[1] == 0x00 &&      // Check preamble
    response[2] == 0x00 &&
    response[3] == 0xFF &&      // Check start code
    response[6] == 0xD5 &&      // Check TFI
    response[7] == 0x03) {      // Check command response
    uint8_t version = response[9];  // Now safe!
}
```

---

## 7. Debugging Tips

### Enable Verbose Logging
Set `PN532_DEBUG_VERBOSE 1` in code to see:
- Every byte sent/received
- Status byte polling attempts
- Timing information
- Frame structure breakdown

### Use Logic Analyzer
Capture actual I2C signals:
- Verify correct address (0x24)
- Check ACK/NACK bits
- Measure actual timing delays
- See clock stretching

### Add Instrumentation
```c
uint32_t start = get_time_ms();
// ... do operation ...
uint32_t elapsed = get_time_ms() - start;
ESP_LOGI(TAG, "Operation took %lu ms", elapsed);
```

### Manual Frame Parsing
When debugging responses:
```c
ESP_LOG_BUFFER_HEX(TAG, response, length);
// Manually decode:
// [0] = status
// [1-3] = preamble/start
// [4] = length
// [5] = length checksum
// [6] = TFI
// etc.
```

---

## 8. Further Learning

### Read the Datasheet
**PN532 User Manual** - Sections to focus on:
- Section 6.2.4: I2C Interface
- Section 7: Host Interface Commands
- Appendix: Frame Format

### Experiment!
Try modifying the code:
- Change delays (make them too short - see it fail!)
- Remove status polling (observe NACK errors)
- Add new commands (InDataExchange, InRelease, etc.)
- Implement UART or SPI modes for comparison

### Use a Logic Analyzer
Tools like:
- Saleae Logic Analyzer
- DSLogic
- Even cheap $10 USB logic analyzers

Can show you **exactly** what's on the wire.

---

## 9. Key Takeaways

1. **I2C is not just "send and receive"** - it's a protocol with timing
2. **Status polling is mandatory** for PN532 I2C mode
3. **Frame validation prevents silent failures**
4. **Delays matter** - the slave needs processing time
5. **Every byte counts** - includes status, checksums, control bytes
6. **Datasheets are your friend** - they contain the truth!

Understanding these fundamentals makes you dangerous in embedded systems - you can debug issues that stump others because you know what's **really** happening at the wire level! ğŸ”§

---

**Written for engineers who want to understand, not just copy-paste.**
